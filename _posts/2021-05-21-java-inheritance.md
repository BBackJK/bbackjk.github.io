---
date:  2021-05-21
title: '자바 다형성과 오버라이딩'
categories:
  - java
tags: 
  - polymorphism
  - oop
  - override
  - overriding

toc: true
toc_sticky: true

author_profile: true
sidebar_main: true
---

# 자바의 다형성

다형성이란 **하나의 클래스나 함수가 다양한 방식으로 동작이 가능한 것**을 의미.

즉, 하나의 메시지를 전달하였을 때 수신자가 누구냐에 따라 다르게 실행되는 것을 말한다.

## 오버로딩

오버로딩은 너무 쉽다. 

이름이 같은 함수라면 컴파일러에서 에러가 나지만

매개변수가 다르다면 메소드 오버로딩이 되어진다.

> 반환타입만 다르다면 그것 또한 에러.


## 오버라이딩

오버라이딩은 부모 객체를 상속받았을 때나 인터페이스를 구현했을 때 일어날 수 있다.

부모 객체를 상속받았을 때 부터 천천히 살펴보자.

```java
// Test.java

class A {
  public void print() {
    System.out.println("this method belongs to A");
  }
}

class B extends A {
  public void print() {
    System.out.println("this method belongs to B");
  }
  public void out() {
    System.out.println("out!!!!");
  }
}

public class Test {

  public static void main(String[] args) {
    A a1 = new A();
    a1.print()  // this is method belongs to A

    A a2 = new B();
    a2.print(); // this is method belongs to B
    // a2.out(); nope!

    B b1 = new B();
    b1.print(); // this is method belongs to B
    b1.out(); // out!!!!
  }
}
```

A 에는 메소드 ``print()``가 존재.

A를 **상속받은** B에는 A와 메소드명이 같은 ``print()`` 와 B에만 존재하는 ``out()`` 이 존재.

자 그럼, main 메소드를 하나씩 해석하자면..

```java
A a1 = new A();
```

라인을 보자. 

타입이 A인 변수명 a1 자체는 Stack에 올라간다.

그 올라간 변수명 a1은 new A();를 받고 있으니 

객체 A는 Heap 메모리에 올라가고

그와 동시에 Heap에 올라간 A 객체의 주소값을 Stack 메모리에 있는 변수 a1가 가지고 있다.

따라서 a1은 Heap에 올라간 A 객체의 모든 변수, 메소드를 다 사용이 가능하다.

```java
A a2 = new B();
```

자 이번에도..

타입을 A로 선언한 변수명 a2 자체는 Stack에 올라간다.

그 올라간 변수명 a2는 new B(); 를 받고 있으니

객체 B는 Heap 메모리에 올라가고

그와 동시에 Heap 메모리에 올라간 B 객체의 주소값을 Stack 메모리에 있는 변수 a2가 가지고있다.

그럼 여기서 의문이 생긴다.

변수명 a2는 객체 B에 대한 힙 메모리 주소를 가지고 있는데 왜 B에 있는 메소드 ``out()``을 사용하지 못하는거지?

실제로 메모리 상으론 B객체는 A객체를 상속받았으므로 컴파일러는 ``super()`` 키워드로 자식 생성자에서 부모 생성자를 호출하게 되면서 B 객체에는 A 객체에 대한 모든 것을 가지고 있음과 동시에 자기 자신 B에 대한 모든 것도 가지고 있다.

> 명시적으로 super()를 해주지 않았으면 컴파일러는 자동적으로 super()를 사용한다.

하지만 이렇게 A 객체에 대한 정보를 가지고 있는 B 객체의 주소값을 알고 있어도 변수명 a2는 타입을 A로 선언했기 때문에 B 객체가 가지고 있는 것에 ``접근이 불가능``하다.

> 처음에는 메모리에 있으면 다 접근가능할 줄 알았는데 안된다니 또 혼란스럽지만 문법상 접근이 불가능하다고 하니 그렇다고 이해할 수 밖에..

> 그리고 이러한 형변환을 묵시적 형변환인 ``업캐스팅`` 이라고 한다.

```java
a2.print();
```

여길 보자. 위에서 설명한 A 타입인 변수 a2가 print() 메소드를 사용하였다.

그런데 출력은 객체 B의 메소드 print()가 출력되었다.

여기까지는 대부분 알고있는 내용이다.

이것을 ``오버라이딩`` 라고 한다.

그리고 이러한 상속관계에서는 ``@Override`` 라는 어노테이션이 없어도 오버라이딩이 된다. (부모클래스의 함수와 이름과 매개변수 갯수, 타입만 같아도!)


그럼 메모리상으로는 B 객체는 자기 자신의 메소드 print()와 A 객체의 메소드 print()를 가지고 있는데 이 것을 어떤 식으로 호출할 지 결정할까?

여기서 ``가상함수`` 와 ``동적바인딩`` 이라는 용어가 나온다.

### 가상함수
<hr/>
이렇게 업캐스팅으로 구현되어있는 오버라이딩 메소드는 

``어떤 클래스 객체`` 냐에 따라 정해지게 된다.

### 동적바인딩

실행시점에서 구현되는 행위.

가상함수 호출에서 **어느 함수를 호출하는가**를 ``실행 시점에 동적으로 결정한다``는 의미.


그리고 또

### vtable

가상함수는 실행시점에서 동적바인딩에 의해 어떤 메소드를 실행할지 결정하며, 이 때 실제 객체의 타입에 따라 어느 메소드가 호출되어져야 하는지는 메모리상에 가지고 있는 vtable을 가지고 한다.

이 vtable은 상속된 모든 조상(자바의 객체로 따지자면 Object)들 까지 정의된 메소드를 전부 가지게 된다.

따라서 오버라이딩된 메소드를 호출하면 vtable에서 가장 마지막으로 오버라이드된 코드를 가르키게 된다.


<hr/>

> 참고 https://plas.tistory.com/29


# 마치면서..

글로만 배웠던 자바의 상속에 대해서 메모리 측면으로 나름 깊게(?) 파보았다.

쓰면서 느낀건.. 정말 잘 설명되어있는 블로그 글들이 너무 많다..

내가 쓰는게 의미가 있나? 싶을 정도로..

근데 어차피 내가 쓰면서 머리속에 넣기위한 기록일뿐이니까..ㅠㅠ..

다음 시간엔 오늘 끝에 말한 **동적바인딩**과 **정적바인딩**에 대해서 포스팅 해보겠다.
